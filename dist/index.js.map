{"version":3,"sources":["../src/index.ts","../src/lib/syntax/wikilink.ts","../src/lib/syntax/highlight.ts","../src/lib/syntax/comment.ts","../src/lib/syntax/tag.ts","../src/lib/mdast/wikilink.ts","../src/lib/mdast/highlight.ts","../src/lib/mdast/comment.ts","../src/lib/mdast/tag.ts","../src/lib/task-char.ts"],"sourcesContent":["/// <reference types=\"remark-parse\" />\n/// <reference types=\"remark-stringify\" />\n\nimport type { Root } from \"mdast\";\nimport type { Processor } from \"unified\";\nimport { visit } from \"unist-util-visit\";\n\nimport \"./lib/types.js\";\n\nimport { wikilinkSyntax } from \"./lib/syntax/wikilink.js\";\nimport { highlightSyntax } from \"./lib/syntax/highlight.js\";\nimport { commentSyntax } from \"./lib/syntax/comment.js\";\nimport { tagSyntax } from \"./lib/syntax/tag.js\";\n\nimport { wikilinkFromMarkdown } from \"./lib/mdast/wikilink.js\";\nimport { highlightFromMarkdown } from \"./lib/mdast/highlight.js\";\nimport { commentFromMarkdown } from \"./lib/mdast/comment.js\";\nimport { tagFromMarkdown } from \"./lib/mdast/tag.js\";\nimport { customTaskCharTransform } from \"./lib/task-char.js\";\n\nexport interface RemarkObsidianOptions {\n  wikilinks?: boolean;\n  highlights?: boolean;\n  comments?: boolean;\n  tags?: boolean;\n  customTaskChars?: boolean;\n}\n\nconst defaultOptions: Required<RemarkObsidianOptions> = {\n  wikilinks: true,\n  highlights: true,\n  comments: true,\n  tags: true,\n  customTaskChars: true,\n};\n\nexport default function remarkObsidian(\n  userOpts?: RemarkObsidianOptions,\n): undefined | ((tree: Root) => void) {\n  const opts = { ...defaultOptions, ...userOpts };\n  // @ts-expect-error - unified `this` context\n  const data = (this as Processor<Root>).data();\n\n  data.micromarkExtensions ??= [];\n  data.fromMarkdownExtensions ??= [];\n\n  if (opts.wikilinks) {\n    data.micromarkExtensions.push(wikilinkSyntax());\n    data.fromMarkdownExtensions.push(wikilinkFromMarkdown());\n  }\n  if (opts.comments) {\n    data.micromarkExtensions.push(commentSyntax());\n    data.fromMarkdownExtensions.push(commentFromMarkdown());\n  }\n  if (opts.tags) {\n    data.micromarkExtensions.push(tagSyntax());\n    data.fromMarkdownExtensions.push(tagFromMarkdown());\n  }\n  if (opts.highlights) {\n    data.micromarkExtensions.push(highlightSyntax());\n    data.fromMarkdownExtensions.push(highlightFromMarkdown());\n  }\n\n  const needsTransform = opts.comments || opts.customTaskChars;\n  if (!needsTransform) return undefined;\n\n  return (tree: Root) => {\n    if (opts.comments) {\n      visit(\n        tree,\n        \"comment\",\n        (_node: unknown, index: number | undefined, parent: any) => {\n          if (parent && typeof index === \"number\") {\n            parent.children.splice(index, 1);\n            return index;\n          }\n          return undefined;\n        },\n      );\n    }\n    if (opts.customTaskChars) {\n      customTaskCharTransform(tree);\n    }\n  };\n}\n\nexport { wikilinkSyntax } from \"./lib/syntax/wikilink.js\";\nexport { highlightSyntax } from \"./lib/syntax/highlight.js\";\nexport { commentSyntax } from \"./lib/syntax/comment.js\";\nexport { tagSyntax } from \"./lib/syntax/tag.js\";\n\nexport { wikilinkFromMarkdown } from \"./lib/mdast/wikilink.js\";\nexport { highlightFromMarkdown } from \"./lib/mdast/highlight.js\";\nexport { commentFromMarkdown } from \"./lib/mdast/comment.js\";\nexport { tagFromMarkdown } from \"./lib/mdast/tag.js\";\nexport { customTaskCharTransform } from \"./lib/task-char.js\";\n\nexport type { Wikilink, Highlight, Comment, Tag } from \"./lib/types.js\";\n","import type {\n  Code,\n  Effects,\n  Extension,\n  State,\n  TokenizeContext,\n} from \"micromark-util-types\";\nimport { codes } from \"micromark-util-symbol\";\n\nconst EXCLAMATION = 33;\nconst HASH = 35;\nconst LEFT_BRACKET = 91;\nconst BACKSLASH = 92;\nconst RIGHT_BRACKET = 93;\nconst PIPE = 124;\n\nfunction isLineEnding(code: Code): boolean {\n  return code === codes.lineFeed || code === codes.carriageReturn;\n}\n\nexport function wikilinkSyntax(): Extension {\n  return {\n    text: {\n      [LEFT_BRACKET]: { name: \"wikilink\", tokenize },\n      [EXCLAMATION]: { name: \"wikilink\", tokenize },\n    },\n  };\n}\n\nfunction tokenize(\n  this: TokenizeContext,\n  effects: Effects,\n  ok: State,\n  nok: State,\n): State {\n  let hasPath = false;\n  let hasHeading = false;\n  let hasAlias = false;\n\n  return start;\n\n  function start(code: Code): State | undefined {\n    if (code === EXCLAMATION) {\n      effects.enter(\"wikilink\");\n      effects.enter(\"wikilinkEmbedMarker\");\n      effects.consume(code);\n      effects.exit(\"wikilinkEmbedMarker\");\n      return openFirst;\n    }\n\n    if (code === LEFT_BRACKET) {\n      effects.enter(\"wikilink\");\n      return openFirst(code);\n    }\n\n    return nok(code);\n  }\n\n  function openFirst(code: Code): State | undefined {\n    if (code !== LEFT_BRACKET) return nok(code);\n    effects.enter(\"wikilinkMarker\");\n    effects.consume(code);\n    return openSecond;\n  }\n\n  function openSecond(code: Code): State | undefined {\n    if (code !== LEFT_BRACKET) return nok(code);\n    effects.consume(code);\n    effects.exit(\"wikilinkMarker\");\n    return pathStart;\n  }\n\n  function pathStart(code: Code): State | undefined {\n    if (code === HASH) return headingMarker(code);\n    if (code === PIPE) return nok(code);\n    if (code === RIGHT_BRACKET || code === null || isLineEnding(code))\n      return nok(code);\n    effects.enter(\"wikilinkPath\");\n    hasPath = true;\n    return path(code);\n  }\n\n  function path(code: Code): State | undefined {\n    if (code === BACKSLASH) {\n      effects.consume(code);\n      return pathEscape;\n    }\n\n    if (code === HASH) {\n      effects.exit(\"wikilinkPath\");\n      return headingMarker(code);\n    }\n\n    if (code === PIPE) {\n      effects.exit(\"wikilinkPath\");\n      return aliasMarker(code);\n    }\n\n    if (code === RIGHT_BRACKET) {\n      effects.exit(\"wikilinkPath\");\n      return closeFirst(code);\n    }\n\n    if (code === null || isLineEnding(code)) return nok(code);\n\n    effects.consume(code);\n    return path;\n  }\n\n  function pathEscape(code: Code): State | undefined {\n    if (code === PIPE) {\n      effects.exit(\"wikilinkPath\");\n      return aliasMarker(code);\n    }\n    if (code === null || isLineEnding(code)) return nok(code);\n    effects.consume(code);\n    return path;\n  }\n\n  function headingMarker(code: Code): State | undefined {\n    if (code !== HASH) return nok(code);\n    effects.enter(\"wikilinkHeadingMarker\");\n    effects.consume(code);\n    effects.exit(\"wikilinkHeadingMarker\");\n    return headingStart;\n  }\n\n  function headingStart(code: Code): State | undefined {\n    if (code === null || isLineEnding(code)) return nok(code);\n\n    // Allow empty heading: [[page#]] or [[page#|alias]]\n    if (code === RIGHT_BRACKET) {\n      hasHeading = true;\n      return closeFirst(code);\n    }\n    if (code === PIPE) {\n      hasHeading = true;\n      return aliasMarker(code);\n    }\n\n    effects.enter(\"wikilinkHeading\");\n    hasHeading = true;\n    return heading(code);\n  }\n\n  function heading(code: Code): State | undefined {\n    if (code === BACKSLASH) {\n      effects.consume(code);\n      return headingEscape;\n    }\n\n    if (code === PIPE) {\n      effects.exit(\"wikilinkHeading\");\n      return aliasMarker(code);\n    }\n\n    if (code === RIGHT_BRACKET) {\n      effects.exit(\"wikilinkHeading\");\n      return closeFirst(code);\n    }\n\n    if (code === null || isLineEnding(code)) return nok(code);\n\n    effects.consume(code);\n    return heading;\n  }\n\n  function headingEscape(code: Code): State | undefined {\n    if (code === PIPE) {\n      effects.exit(\"wikilinkHeading\");\n      return aliasMarker(code);\n    }\n    if (code === null || isLineEnding(code)) return nok(code);\n    effects.consume(code);\n    return heading;\n  }\n\n  function aliasMarker(code: Code): State | undefined {\n    if (code !== PIPE) return nok(code);\n    effects.enter(\"wikilinkAliasMarker\");\n    effects.consume(code);\n    effects.exit(\"wikilinkAliasMarker\");\n    return aliasStart;\n  }\n\n  function aliasStart(code: Code): State | undefined {\n    if (code === RIGHT_BRACKET) return closeFirst(code);\n    if (code === null || isLineEnding(code)) return nok(code);\n    effects.enter(\"wikilinkAlias\");\n    hasAlias = true;\n    return alias(code);\n  }\n\n  function alias(code: Code): State | undefined {\n    if (code === RIGHT_BRACKET) {\n      effects.exit(\"wikilinkAlias\");\n      return closeFirst(code);\n    }\n\n    if (code === null || isLineEnding(code)) return nok(code);\n\n    effects.consume(code);\n    return alias;\n  }\n\n  function closeFirst(code: Code): State | undefined {\n    if (code !== RIGHT_BRACKET) return nok(code);\n    if (!hasPath && !hasHeading && !hasAlias) return nok(code);\n    effects.enter(\"wikilinkMarker\");\n    effects.consume(code);\n    return closeSecond;\n  }\n\n  function closeSecond(code: Code): State | undefined {\n    if (code !== RIGHT_BRACKET) return nok(code);\n    effects.consume(code);\n    effects.exit(\"wikilinkMarker\");\n    effects.exit(\"wikilink\");\n    return ok;\n  }\n}\n","import type {\n  Code,\n  Construct,\n  Effects,\n  Extension,\n  State,\n  TokenizeContext,\n} from \"micromark-util-types\";\nimport { codes } from \"micromark-util-symbol\";\n\nconst EQUALS = 61;\n\nfunction isLineEnding(code: Code): boolean {\n  return code === codes.lineFeed || code === codes.carriageReturn;\n}\n\nexport function highlightSyntax(): Extension {\n  return {\n    text: {\n      [EQUALS]: { name: \"highlight\", tokenize },\n    },\n  };\n}\n\nfunction tokenize(\n  this: TokenizeContext,\n  effects: Effects,\n  ok: State,\n  nok: State,\n): State {\n  const close: Construct = { tokenize: tokenizeClose, partial: true };\n  let hasContent = false;\n  return start;\n\n  function start(code: Code): State | undefined {\n    if (code !== EQUALS) return nok(code);\n    effects.enter(\"highlight\");\n    effects.enter(\"highlightMarker\");\n    effects.consume(code);\n    return openSecond;\n  }\n\n  function openSecond(code: Code): State | undefined {\n    if (code !== EQUALS) return nok(code);\n    effects.consume(code);\n    effects.exit(\"highlightMarker\");\n    effects.enter(\"highlightContent\");\n    return content;\n  }\n\n  function content(code: Code): State | undefined {\n    if (code === null || isLineEnding(code)) return nok(code);\n    if (!hasContent && (code === EQUALS || code === codes.greaterThan))\n      return nok(code);\n    if (code === EQUALS)\n      return effects.attempt(close, closeAfter, contentConsume)(code);\n    effects.consume(code);\n    hasContent = true;\n    return content;\n  }\n\n  function contentConsume(code: Code): State | undefined {\n    if (code === null || isLineEnding(code)) return nok(code);\n    effects.consume(code);\n    return content;\n  }\n\n  function tokenizeClose(\n    this: TokenizeContext,\n    closeEffects: Effects,\n    closeOk: State,\n    closeNok: State,\n  ): State {\n    return closeStart;\n\n    function closeStart(closeCode: Code): State | undefined {\n      if (closeCode !== EQUALS) return closeNok(closeCode);\n      closeEffects.exit(\"highlightContent\");\n      closeEffects.enter(\"highlightMarker\");\n      closeEffects.consume(closeCode);\n      return closeSecond;\n    }\n\n    function closeSecond(closeCode: Code): State | undefined {\n      if (closeCode !== EQUALS) return closeNok(closeCode);\n      closeEffects.consume(closeCode);\n      closeEffects.exit(\"highlightMarker\");\n      return closeOk;\n    }\n  }\n\n  function closeAfter(code: Code): State | undefined {\n    effects.exit(\"highlight\");\n    return ok(code);\n  }\n}\n","import type {\n  Code,\n  Construct,\n  Effects,\n  Extension,\n  State,\n  TokenizeContext,\n} from \"micromark-util-types\";\n\nconst PERCENT = 37;\nconst LINE_FEED = -4;\nconst CARRIAGE_RETURN = -3;\nconst CARRIAGE_RETURN_LINE_FEED = -5;\n\nfunction isLineEnding(code: Code): code is number {\n  return (\n    code === LINE_FEED ||\n    code === CARRIAGE_RETURN ||\n    code === CARRIAGE_RETURN_LINE_FEED\n  );\n}\n\nconst commentFlow: Construct = {\n  tokenize: tokenizeFlow,\n  concrete: true,\n  name: \"commentFlow\",\n};\n\nconst nonLazyContinuation: Construct = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true,\n};\n\nexport function commentSyntax(): Extension {\n  return {\n    text: {\n      [PERCENT]: { name: \"comment\", tokenize: tokenizeText },\n    },\n    flow: {\n      [PERCENT]: commentFlow,\n    },\n  };\n}\n\nfunction tokenizeText(\n  this: TokenizeContext,\n  effects: Effects,\n  ok: State,\n  nok: State,\n): State {\n  const close: Construct = { tokenize: tokenizeClose, partial: true };\n  return start;\n\n  function start(code: Code): State | undefined {\n    if (code !== PERCENT) return nok(code);\n    effects.enter(\"comment\");\n    effects.enter(\"commentMarker\");\n    effects.consume(code);\n    return openSecond;\n  }\n\n  function openSecond(code: Code): State | undefined {\n    if (code !== PERCENT) return nok(code);\n    effects.consume(code);\n    effects.exit(\"commentMarker\");\n    effects.enter(\"commentContent\");\n    return content;\n  }\n\n  function content(code: Code): State | undefined {\n    if (code === null) return nok(code);\n    if (code === PERCENT)\n      return effects.attempt(close, closeAfter, contentConsume)(code);\n    effects.consume(code);\n    return content;\n  }\n\n  function contentConsume(code: Code): State | undefined {\n    if (code === null) return nok(code);\n    effects.consume(code);\n    return content;\n  }\n\n  function tokenizeClose(\n    this: TokenizeContext,\n    closeEffects: Effects,\n    closeOk: State,\n    closeNok: State,\n  ): State {\n    return closeStart;\n\n    function closeStart(closeCode: Code): State | undefined {\n      if (closeCode !== PERCENT) return closeNok(closeCode);\n      closeEffects.exit(\"commentContent\");\n      closeEffects.enter(\"commentMarker\");\n      closeEffects.consume(closeCode);\n      return closeSecond;\n    }\n\n    function closeSecond(closeCode: Code): State | undefined {\n      if (closeCode !== PERCENT) return closeNok(closeCode);\n      closeEffects.consume(closeCode);\n      closeEffects.exit(\"commentMarker\");\n      return closeOk;\n    }\n  }\n\n  function closeAfter(code: Code): State | undefined {\n    effects.exit(\"comment\");\n    return ok(code);\n  }\n}\n\nfunction tokenizeFlow(\n  this: TokenizeContext,\n  effects: Effects,\n  ok: State,\n  nok: State,\n): State {\n  const self = this;\n  const flowClose: Construct = {\n    tokenize: tokenizeFlowClose,\n    partial: true,\n  };\n\n  return start;\n\n  function start(code: Code): State | undefined {\n    if (code !== PERCENT) return nok(code);\n    effects.enter(\"comment\");\n    effects.enter(\"commentMarker\");\n    effects.consume(code);\n    return openSecond;\n  }\n\n  function openSecond(code: Code): State | undefined {\n    if (code !== PERCENT) return nok(code);\n    effects.consume(code);\n    effects.exit(\"commentMarker\");\n    return afterOpen;\n  }\n\n  function afterOpen(code: Code): State | undefined {\n    if (code === null) return nok(code);\n\n    if (isLineEnding(code)) {\n      return effects.attempt(\n        nonLazyContinuation,\n        beforeContentChunk,\n        abandon,\n      )(code);\n    }\n\n    effects.enter(\"commentContent\");\n    return contentChunk(code);\n  }\n\n  function beforeContentChunk(code: Code): State | undefined {\n    if (code === null) {\n      return abandon(code);\n    }\n\n    if (code === PERCENT) {\n      return effects.attempt(flowClose, closeAfter, startContent)(code);\n    }\n\n    effects.enter(\"commentContent\");\n    return contentChunk(code);\n  }\n\n  function startContent(code: Code): State | undefined {\n    effects.enter(\"commentContent\");\n    effects.consume(code);\n    return contentChunk;\n  }\n\n  function contentChunk(code: Code): State | undefined {\n    if (code === null) return abandon(code);\n\n    if (code === PERCENT) {\n      return effects.attempt(flowClose, closeAfter, contentConsume)(code);\n    }\n\n    if (isLineEnding(code)) {\n      effects.exit(\"commentContent\");\n      return effects.attempt(\n        nonLazyContinuation,\n        beforeContentChunk,\n        abandon,\n      )(code);\n    }\n\n    effects.consume(code);\n    return contentChunk;\n  }\n\n  function contentConsume(code: Code): State | undefined {\n    if (code === null) return abandon(code);\n    effects.consume(code);\n    return contentChunk;\n  }\n\n  function closeAfter(code: Code): State | undefined {\n    effects.exit(\"comment\");\n    return ok(code);\n  }\n\n  function abandon(code: Code): State | undefined {\n    effects.exit(\"comment\");\n    return nok(code);\n  }\n\n  function tokenizeFlowClose(\n    this: TokenizeContext,\n    closeEffects: Effects,\n    closeOk: State,\n    closeNok: State,\n  ): State {\n    let inContent = false;\n    return closeStart;\n\n    function closeStart(closeCode: Code): State | undefined {\n      if (closeCode !== PERCENT) return closeNok(closeCode);\n      const current = self.events[self.events.length - 1];\n      if (\n        current &&\n        current[0] === \"enter\" &&\n        current[1].type === \"commentContent\"\n      ) {\n        closeEffects.exit(\"commentContent\");\n        inContent = true;\n      }\n      closeEffects.enter(\"commentMarker\");\n      closeEffects.consume(closeCode);\n      return closeSecond;\n    }\n\n    function closeSecond(closeCode: Code): State | undefined {\n      if (closeCode !== PERCENT) {\n        if (inContent) {\n          closeEffects.exit(\"commentMarker\");\n          closeEffects.enter(\"commentContent\");\n        }\n        return closeNok(closeCode);\n      }\n      closeEffects.consume(closeCode);\n      closeEffects.exit(\"commentMarker\");\n      return closeOk;\n    }\n  }\n}\n\nfunction tokenizeNonLazyContinuation(\n  this: TokenizeContext,\n  effects: Effects,\n  ok: State,\n  nok: State,\n): State {\n  const self = this;\n  return start;\n\n  function start(code: Code): State | undefined {\n    if (code === null) {\n      return ok(code);\n    }\n    if (!isLineEnding(code)) return nok(code);\n    effects.enter(\"lineEnding\");\n    effects.consume(code);\n    effects.exit(\"lineEnding\");\n    return lineStart;\n  }\n\n  function lineStart(code: Code): State | undefined {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}\n","import type {\n  Code,\n  Effects,\n  Extension,\n  State,\n  TokenizeContext,\n} from \"micromark-util-types\";\nimport { codes } from \"micromark-util-symbol\";\n\nconst HASH = 35;\nconst SLASH = 47;\nconst DASH = 45;\nconst UNDERSCORE = 95;\n\nconst tagCharRegex = /[\\p{L}\\p{M}\\p{Emoji}]/u;\n\nfunction isWhitespace(code: Code): boolean {\n  return (\n    code === codes.space ||\n    code === codes.horizontalTab ||\n    code === codes.lineFeed ||\n    code === codes.carriageReturn ||\n    code === codes.carriageReturnLineFeed\n  );\n}\n\nfunction isTagChar(code: Code): boolean {\n  if (code === null) return false;\n  if (code >= 48 && code <= 57) return true;\n  if (code === DASH || code === UNDERSCORE) return true;\n  return tagCharRegex.test(String.fromCodePoint(code));\n}\n\nfunction isNonDigit(code: Code): boolean {\n  if (code === null) return false;\n  return !(code >= 48 && code <= 57);\n}\n\nexport function tagSyntax(): Extension {\n  return {\n    text: {\n      [HASH]: { name: \"tag\", tokenize },\n    },\n  };\n}\n\nfunction tokenize(\n  this: TokenizeContext,\n  effects: Effects,\n  ok: State,\n  nok: State,\n): State {\n  let hasNonDigit = false;\n  const context = this;\n\n  return start;\n\n  function start(code: Code): State | undefined {\n    const previous = context.previous;\n    const allowedStart =\n      previous === null || isWhitespace(previous) || previous === HASH;\n    if (!allowedStart) return nok(code);\n    if (code !== HASH) return nok(code);\n    effects.enter(\"tag\");\n    effects.enter(\"tagMarker\");\n    effects.consume(code);\n    effects.exit(\"tagMarker\");\n    return tagStart;\n  }\n\n  function tagStart(code: Code): State | undefined {\n    if (!isTagChar(code)) return nok(code);\n    effects.enter(\"tagContent\");\n    if (isNonDigit(code)) hasNonDigit = true;\n    effects.consume(code);\n    return tagContent;\n  }\n\n  function tagContent(code: Code): State | undefined {\n    if (code === SLASH) {\n      effects.consume(code);\n      return afterSlash;\n    }\n\n    if (isTagChar(code)) {\n      if (isNonDigit(code)) hasNonDigit = true;\n      effects.consume(code);\n      return tagContent;\n    }\n\n    return end(code);\n  }\n\n  function afterSlash(code: Code): State | undefined {\n    if (!isTagChar(code)) return nok(code);\n    if (isNonDigit(code)) hasNonDigit = true;\n    effects.consume(code);\n    return tagContent;\n  }\n\n  function end(code: Code): State | undefined {\n    if (!hasNonDigit) return nok(code);\n    effects.exit(\"tagContent\");\n    effects.exit(\"tag\");\n    return ok(code);\n  }\n}\n","import type { Extension } from \"mdast-util-from-markdown\";\n\nexport function wikilinkFromMarkdown(): Extension {\n  return {\n    enter: {\n      wikilink(token) {\n        this.enter(\n          {\n            type: \"wikilink\",\n            value: \"\",\n            embedded: false,\n            path: \"\",\n            heading: \"\",\n            alias: \"\",\n          },\n          token,\n        );\n      },\n      wikilinkEmbedMarker() {\n        const node = this.stack[this.stack.length - 1] as any;\n        node.embedded = true;\n      },\n      wikilinkPath(token) {\n        const node = this.stack[this.stack.length - 1] as any;\n        node.path = this.sliceSerialize(token).replace(/\\\\([#\\[\\]])/g, \"$1\");\n      },\n      wikilinkHeading(token) {\n        const node = this.stack[this.stack.length - 1] as any;\n        node.heading = this.sliceSerialize(token).replace(/\\\\([#\\[\\]])/g, \"$1\");\n      },\n      wikilinkAlias(token) {\n        const node = this.stack[this.stack.length - 1] as any;\n        node.alias = this.sliceSerialize(token);\n      },\n    },\n    exit: {\n      wikilink(token) {\n        const node = this.stack[this.stack.length - 1] as any;\n        if (node.alias) {\n          if (node.path.endsWith(\"\\\\\")) node.path = node.path.slice(0, -1);\n          if (node.heading.endsWith(\"\\\\\"))\n            node.heading = node.heading.slice(0, -1);\n        }\n        this.exit(token);\n      },\n    },\n  };\n}\n","import type { Extension } from \"mdast-util-from-markdown\";\n\nexport function highlightFromMarkdown(): Extension {\n  return {\n    enter: {\n      highlight(token) {\n        this.enter({ type: \"highlight\", children: [] }, token);\n      },\n    },\n    exit: {\n      highlightContent(token) {\n        const node = this.stack[this.stack.length - 1] as any;\n        node.children = [{ type: \"text\", value: this.sliceSerialize(token) }];\n      },\n      highlight(token) {\n        this.exit(token);\n      },\n    },\n  };\n}\n","import type { Extension } from \"mdast-util-from-markdown\";\n\nexport function commentFromMarkdown(): Extension {\n  return {\n    enter: {\n      comment(token) {\n        this.enter({ type: \"comment\", value: \"\" }, token);\n      },\n    },\n    exit: {\n      commentContent(token) {\n        const node = this.stack[this.stack.length - 1] as any;\n        node.value = this.sliceSerialize(token);\n      },\n      comment(token) {\n        this.exit(token);\n      },\n    },\n  };\n}\n","import type { Extension } from \"mdast-util-from-markdown\";\n\nexport function tagFromMarkdown(): Extension {\n  return {\n    enter: {\n      tag(token) {\n        this.enter({ type: \"tag\", value: \"\" }, token);\n      },\n      tagContent(token) {\n        const node = this.stack[this.stack.length - 1] as any;\n        if (node.type === \"tag\") node.value = this.sliceSerialize(token);\n      },\n    },\n    exit: {\n      tag(token) {\n        this.exit(token);\n      },\n    },\n  };\n}\n","import type { Root } from \"mdast\";\nimport { visit } from \"unist-util-visit\";\n\nexport function customTaskCharTransform(tree: Root) {\n  visit(tree, \"listItem\", (node: any) => {\n    if (typeof node.checked === \"boolean\") {\n      const char = node.checked ? \"x\" : \" \";\n      node.data ??= {};\n      node.data.taskChar = char;\n      node.data.hProperties ??= {};\n      node.data.hProperties.dataTaskChar = char;\n      return;\n    }\n\n    const firstChild = node.children?.[0];\n    if (!firstChild || firstChild.type !== \"paragraph\") return;\n\n    const firstText = firstChild.children?.[0];\n    if (!firstText || firstText.type !== \"text\") return;\n\n    const match = firstText.value.match(/^\\[([^\\]])\\]\\s/);\n    if (!match) return;\n\n    const taskChar = match[1];\n\n    node.checked = taskChar !== \" \";\n    node.data ??= {};\n    node.data.taskChar = taskChar;\n    node.data.hProperties ??= {};\n    node.data.hProperties.dataTaskChar = taskChar;\n\n    firstText.value = firstText.value.slice(match[0].length);\n\n    if (firstText.value.length === 0) {\n      firstChild.children.shift();\n    } else if (\n      firstText.position &&\n      typeof firstText.position.start.offset === \"number\"\n    ) {\n      firstText.position.start.column += match[0].length;\n      firstText.position.start.offset += match[0].length;\n    }\n  });\n}\n"],"mappings":"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","names":["visit","codes","isLineEnding","tokenize","isLineEnding","codes","HASH","tokenize","visit"]}