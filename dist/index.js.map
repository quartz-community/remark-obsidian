{"version":3,"sources":["../src/index.ts","../src/lib/syntax/wikilink.ts","../src/lib/syntax/highlight.ts","../src/lib/syntax/comment.ts","../src/lib/syntax/tag.ts","../src/lib/syntax/arrow.ts","../src/lib/mdast/wikilink.ts","../src/lib/mdast/highlight.ts","../src/lib/mdast/comment.ts","../src/lib/mdast/tag.ts","../src/lib/mdast/arrow.ts"],"sourcesContent":["/// <reference types=\"remark-parse\" />\n/// <reference types=\"remark-stringify\" />\n\nimport type { Root } from \"mdast\";\nimport type { Processor } from \"unified\";\nimport { visit } from \"unist-util-visit\";\n\nimport \"./lib/types.js\";\n\nimport { wikilinkSyntax } from \"./lib/syntax/wikilink.js\";\nimport { highlightSyntax } from \"./lib/syntax/highlight.js\";\nimport { commentSyntax } from \"./lib/syntax/comment.js\";\nimport { tagSyntax } from \"./lib/syntax/tag.js\";\nimport { arrowSyntax } from \"./lib/syntax/arrow.js\";\n\nimport { wikilinkFromMarkdown } from \"./lib/mdast/wikilink.js\";\nimport { highlightFromMarkdown } from \"./lib/mdast/highlight.js\";\nimport { commentFromMarkdown } from \"./lib/mdast/comment.js\";\nimport { tagFromMarkdown } from \"./lib/mdast/tag.js\";\nimport { arrowFromMarkdown } from \"./lib/mdast/arrow.js\";\n\nexport interface RemarkObsidianOptions {\n  wikilinks?: boolean;\n  highlights?: boolean;\n  comments?: boolean;\n  tags?: boolean;\n  arrows?: boolean;\n}\n\nconst defaultOptions: Required<RemarkObsidianOptions> = {\n  wikilinks: true,\n  highlights: true,\n  comments: true,\n  tags: true,\n  arrows: true,\n};\n\nexport default function remarkObsidian(\n  userOpts?: RemarkObsidianOptions,\n): undefined | ((tree: Root) => void) {\n  const opts = { ...defaultOptions, ...userOpts };\n  // @ts-expect-error - unified `this` context\n  const data = (this as Processor<Root>).data();\n\n  data.micromarkExtensions ??= [];\n  data.fromMarkdownExtensions ??= [];\n\n  if (opts.wikilinks) {\n    data.micromarkExtensions.push(wikilinkSyntax());\n    data.fromMarkdownExtensions.push(wikilinkFromMarkdown());\n  }\n  if (opts.comments) {\n    data.micromarkExtensions.push(commentSyntax());\n    data.fromMarkdownExtensions.push(commentFromMarkdown());\n  }\n  if (opts.tags) {\n    data.micromarkExtensions.push(tagSyntax());\n    data.fromMarkdownExtensions.push(tagFromMarkdown());\n  }\n  if (opts.arrows) {\n    data.micromarkExtensions.push(arrowSyntax());\n    data.fromMarkdownExtensions.push(arrowFromMarkdown());\n  }\n  if (opts.highlights) {\n    data.micromarkExtensions.push(highlightSyntax());\n    data.fromMarkdownExtensions.push(highlightFromMarkdown());\n  }\n\n  if (!opts.comments) return undefined;\n\n  return (tree) => {\n    visit(\n      tree,\n      \"comment\",\n      (_node: unknown, index: number | undefined, parent: any) => {\n        if (parent && typeof index === \"number\") {\n          parent.children.splice(index, 1);\n          return index;\n        }\n        return undefined;\n      },\n    );\n  };\n}\n\nexport { wikilinkSyntax } from \"./lib/syntax/wikilink.js\";\nexport { highlightSyntax } from \"./lib/syntax/highlight.js\";\nexport { commentSyntax } from \"./lib/syntax/comment.js\";\nexport { tagSyntax } from \"./lib/syntax/tag.js\";\nexport { arrowSyntax } from \"./lib/syntax/arrow.js\";\n\nexport { wikilinkFromMarkdown } from \"./lib/mdast/wikilink.js\";\nexport { highlightFromMarkdown } from \"./lib/mdast/highlight.js\";\nexport { commentFromMarkdown } from \"./lib/mdast/comment.js\";\nexport { tagFromMarkdown } from \"./lib/mdast/tag.js\";\nexport { arrowFromMarkdown } from \"./lib/mdast/arrow.js\";\n\nexport type { Wikilink, Highlight, Comment, Tag, Arrow } from \"./lib/types.js\";\n","import type {\n  Code,\n  Effects,\n  Extension,\n  State,\n  TokenizeContext,\n} from \"micromark-util-types\";\nimport { codes } from \"micromark-util-symbol\";\n\nconst EXCLAMATION = 33;\nconst HASH = 35;\nconst LEFT_BRACKET = 91;\nconst BACKSLASH = 92;\nconst RIGHT_BRACKET = 93;\nconst PIPE = 124;\n\nfunction isLineEnding(code: Code): boolean {\n  return code === codes.lineFeed || code === codes.carriageReturn;\n}\n\nexport function wikilinkSyntax(): Extension {\n  return {\n    text: {\n      [LEFT_BRACKET]: { name: \"wikilink\", tokenize },\n      [EXCLAMATION]: { name: \"wikilink\", tokenize },\n    },\n  };\n}\n\nfunction tokenize(\n  this: TokenizeContext,\n  effects: Effects,\n  ok: State,\n  nok: State,\n): State {\n  let hasPath = false;\n  let hasHeading = false;\n  let hasAlias = false;\n\n  return start;\n\n  function start(code: Code): State | undefined {\n    if (code === EXCLAMATION) {\n      effects.enter(\"wikilink\");\n      effects.enter(\"wikilinkEmbedMarker\");\n      effects.consume(code);\n      effects.exit(\"wikilinkEmbedMarker\");\n      return openFirst;\n    }\n\n    if (code === LEFT_BRACKET) {\n      effects.enter(\"wikilink\");\n      return openFirst(code);\n    }\n\n    return nok(code);\n  }\n\n  function openFirst(code: Code): State | undefined {\n    if (code !== LEFT_BRACKET) return nok(code);\n    effects.enter(\"wikilinkMarker\");\n    effects.consume(code);\n    return openSecond;\n  }\n\n  function openSecond(code: Code): State | undefined {\n    if (code !== LEFT_BRACKET) return nok(code);\n    effects.consume(code);\n    effects.exit(\"wikilinkMarker\");\n    return pathStart;\n  }\n\n  function pathStart(code: Code): State | undefined {\n    if (code === HASH) return headingMarker(code);\n    if (code === PIPE) return nok(code);\n    if (code === RIGHT_BRACKET || code === null || isLineEnding(code))\n      return nok(code);\n    effects.enter(\"wikilinkPath\");\n    hasPath = true;\n    return path(code);\n  }\n\n  function path(code: Code): State | undefined {\n    if (code === BACKSLASH) {\n      effects.consume(code);\n      return pathEscape;\n    }\n\n    if (code === HASH) {\n      effects.exit(\"wikilinkPath\");\n      return headingMarker(code);\n    }\n\n    if (code === PIPE) {\n      effects.exit(\"wikilinkPath\");\n      return aliasMarker(code);\n    }\n\n    if (code === RIGHT_BRACKET) {\n      effects.exit(\"wikilinkPath\");\n      return closeFirst(code);\n    }\n\n    if (code === null || isLineEnding(code)) return nok(code);\n\n    effects.consume(code);\n    return path;\n  }\n\n  function pathEscape(code: Code): State | undefined {\n    if (code === null || isLineEnding(code)) return nok(code);\n    effects.consume(code);\n    return path;\n  }\n\n  function headingMarker(code: Code): State | undefined {\n    if (code !== HASH) return nok(code);\n    effects.enter(\"wikilinkHeadingMarker\");\n    effects.consume(code);\n    effects.exit(\"wikilinkHeadingMarker\");\n    return headingStart;\n  }\n\n  function headingStart(code: Code): State | undefined {\n    if (code === PIPE) return nok(code);\n    if (code === RIGHT_BRACKET || code === null || isLineEnding(code))\n      return nok(code);\n    effects.enter(\"wikilinkHeading\");\n    hasHeading = true;\n    return heading(code);\n  }\n\n  function heading(code: Code): State | undefined {\n    if (code === PIPE) {\n      effects.exit(\"wikilinkHeading\");\n      return aliasMarker(code);\n    }\n\n    if (code === RIGHT_BRACKET) {\n      effects.exit(\"wikilinkHeading\");\n      return closeFirst(code);\n    }\n\n    if (code === null || isLineEnding(code)) return nok(code);\n\n    effects.consume(code);\n    return heading;\n  }\n\n  function aliasMarker(code: Code): State | undefined {\n    if (code !== PIPE) return nok(code);\n    effects.enter(\"wikilinkAliasMarker\");\n    effects.consume(code);\n    effects.exit(\"wikilinkAliasMarker\");\n    return aliasStart;\n  }\n\n  function aliasStart(code: Code): State | undefined {\n    if (code === RIGHT_BRACKET) return closeFirst(code);\n    if (code === null || isLineEnding(code)) return nok(code);\n    effects.enter(\"wikilinkAlias\");\n    hasAlias = true;\n    return alias(code);\n  }\n\n  function alias(code: Code): State | undefined {\n    if (code === RIGHT_BRACKET) {\n      effects.exit(\"wikilinkAlias\");\n      return closeFirst(code);\n    }\n\n    if (code === null || isLineEnding(code)) return nok(code);\n\n    effects.consume(code);\n    return alias;\n  }\n\n  function closeFirst(code: Code): State | undefined {\n    if (code !== RIGHT_BRACKET) return nok(code);\n    if (!hasPath && !hasHeading && !hasAlias) return nok(code);\n    effects.enter(\"wikilinkMarker\");\n    effects.consume(code);\n    return closeSecond;\n  }\n\n  function closeSecond(code: Code): State | undefined {\n    if (code !== RIGHT_BRACKET) return nok(code);\n    effects.consume(code);\n    effects.exit(\"wikilinkMarker\");\n    effects.exit(\"wikilink\");\n    return ok;\n  }\n}\n","import type {\n  Code,\n  Construct,\n  Effects,\n  Extension,\n  State,\n  TokenizeContext,\n} from \"micromark-util-types\";\nimport { codes } from \"micromark-util-symbol\";\n\nconst EQUALS = 61;\n\nfunction isLineEnding(code: Code): boolean {\n  return code === codes.lineFeed || code === codes.carriageReturn;\n}\n\nexport function highlightSyntax(): Extension {\n  return {\n    text: {\n      [EQUALS]: { name: \"highlight\", tokenize },\n    },\n  };\n}\n\nfunction tokenize(\n  this: TokenizeContext,\n  effects: Effects,\n  ok: State,\n  nok: State,\n): State {\n  const close: Construct = { tokenize: tokenizeClose, partial: true };\n  let hasContent = false;\n  return start;\n\n  function start(code: Code): State | undefined {\n    if (code !== EQUALS) return nok(code);\n    effects.enter(\"highlight\");\n    effects.enter(\"highlightMarker\");\n    effects.consume(code);\n    return openSecond;\n  }\n\n  function openSecond(code: Code): State | undefined {\n    if (code !== EQUALS) return nok(code);\n    effects.consume(code);\n    effects.exit(\"highlightMarker\");\n    effects.enter(\"highlightContent\");\n    return content;\n  }\n\n  function content(code: Code): State | undefined {\n    if (code === null || isLineEnding(code)) return nok(code);\n    if (!hasContent && (code === EQUALS || code === codes.greaterThan))\n      return nok(code);\n    if (code === EQUALS)\n      return effects.attempt(close, closeAfter, contentConsume)(code);\n    effects.consume(code);\n    hasContent = true;\n    return content;\n  }\n\n  function contentConsume(code: Code): State | undefined {\n    if (code === null || isLineEnding(code)) return nok(code);\n    effects.consume(code);\n    return content;\n  }\n\n  function tokenizeClose(\n    this: TokenizeContext,\n    closeEffects: Effects,\n    closeOk: State,\n    closeNok: State,\n  ): State {\n    return closeStart;\n\n    function closeStart(closeCode: Code): State | undefined {\n      if (closeCode !== EQUALS) return closeNok(closeCode);\n      closeEffects.exit(\"highlightContent\");\n      closeEffects.enter(\"highlightMarker\");\n      closeEffects.consume(closeCode);\n      return closeSecond;\n    }\n\n    function closeSecond(closeCode: Code): State | undefined {\n      if (closeCode !== EQUALS) return closeNok(closeCode);\n      closeEffects.consume(closeCode);\n      closeEffects.exit(\"highlightMarker\");\n      return closeOk;\n    }\n  }\n\n  function closeAfter(code: Code): State | undefined {\n    effects.exit(\"highlight\");\n    return ok(code);\n  }\n}\n","import type {\n  Code,\n  Construct,\n  Effects,\n  Extension,\n  State,\n  TokenizeContext,\n} from \"micromark-util-types\";\n\nconst PERCENT = 37;\n\nexport function commentSyntax(): Extension {\n  return {\n    text: {\n      [PERCENT]: { name: \"comment\", tokenize },\n    },\n    flow: {\n      [PERCENT]: { name: \"comment\", tokenize },\n    },\n  };\n}\n\nfunction tokenize(\n  this: TokenizeContext,\n  effects: Effects,\n  ok: State,\n  nok: State,\n): State {\n  const close: Construct = { tokenize: tokenizeClose, partial: true };\n  return start;\n\n  function start(code: Code): State | undefined {\n    if (code !== PERCENT) return nok(code);\n    effects.enter(\"comment\");\n    effects.enter(\"commentMarker\");\n    effects.consume(code);\n    return openSecond;\n  }\n\n  function openSecond(code: Code): State | undefined {\n    if (code !== PERCENT) return nok(code);\n    effects.consume(code);\n    effects.exit(\"commentMarker\");\n    effects.enter(\"commentContent\");\n    return content;\n  }\n\n  function content(code: Code): State | undefined {\n    if (code === null) return nok(code);\n    if (code === PERCENT)\n      return effects.attempt(close, closeAfter, contentConsume)(code);\n    effects.consume(code);\n    return content;\n  }\n\n  function contentConsume(code: Code): State | undefined {\n    if (code === null) return nok(code);\n    effects.consume(code);\n    return content;\n  }\n\n  function tokenizeClose(\n    this: TokenizeContext,\n    closeEffects: Effects,\n    closeOk: State,\n    closeNok: State,\n  ): State {\n    return closeStart;\n\n    function closeStart(closeCode: Code): State | undefined {\n      if (closeCode !== PERCENT) return closeNok(closeCode);\n      closeEffects.exit(\"commentContent\");\n      closeEffects.enter(\"commentMarker\");\n      closeEffects.consume(closeCode);\n      return closeSecond;\n    }\n\n    function closeSecond(closeCode: Code): State | undefined {\n      if (closeCode !== PERCENT) return closeNok(closeCode);\n      closeEffects.consume(closeCode);\n      closeEffects.exit(\"commentMarker\");\n      return closeOk;\n    }\n  }\n\n  function closeAfter(code: Code): State | undefined {\n    effects.exit(\"comment\");\n    return ok(code);\n  }\n}\n","import type {\n  Code,\n  Effects,\n  Extension,\n  State,\n  TokenizeContext,\n} from \"micromark-util-types\";\nimport { codes } from \"micromark-util-symbol\";\n\nconst HASH = 35;\nconst SLASH = 47;\nconst DASH = 45;\nconst UNDERSCORE = 95;\n\nconst tagCharRegex = /[\\p{L}\\p{M}\\p{Emoji}]/u;\n\nfunction isWhitespace(code: Code): boolean {\n  return (\n    code === codes.space ||\n    code === codes.horizontalTab ||\n    code === codes.lineFeed ||\n    code === codes.carriageReturn ||\n    code === codes.carriageReturnLineFeed\n  );\n}\n\nfunction isTagChar(code: Code): boolean {\n  if (code === null) return false;\n  if (code >= 48 && code <= 57) return true;\n  if (code === DASH || code === UNDERSCORE) return true;\n  return tagCharRegex.test(String.fromCodePoint(code));\n}\n\nfunction isNonDigit(code: Code): boolean {\n  if (code === null) return false;\n  return !(code >= 48 && code <= 57);\n}\n\nexport function tagSyntax(): Extension {\n  return {\n    text: {\n      [HASH]: { name: \"tag\", tokenize },\n    },\n  };\n}\n\nfunction tokenize(\n  this: TokenizeContext,\n  effects: Effects,\n  ok: State,\n  nok: State,\n): State {\n  let hasNonDigit = false;\n  const context = this;\n\n  return start;\n\n  function start(code: Code): State | undefined {\n    const previous = context.previous;\n    const allowedStart =\n      previous === null || isWhitespace(previous) || previous === HASH;\n    if (!allowedStart) return nok(code);\n    if (code !== HASH) return nok(code);\n    effects.enter(\"tag\");\n    effects.enter(\"tagMarker\");\n    effects.consume(code);\n    effects.exit(\"tagMarker\");\n    return tagStart;\n  }\n\n  function tagStart(code: Code): State | undefined {\n    if (!isTagChar(code)) return nok(code);\n    effects.enter(\"tagContent\");\n    if (isNonDigit(code)) hasNonDigit = true;\n    effects.consume(code);\n    return tagContent;\n  }\n\n  function tagContent(code: Code): State | undefined {\n    if (code === SLASH) {\n      effects.consume(code);\n      return afterSlash;\n    }\n\n    if (isTagChar(code)) {\n      if (isNonDigit(code)) hasNonDigit = true;\n      effects.consume(code);\n      return tagContent;\n    }\n\n    return end(code);\n  }\n\n  function afterSlash(code: Code): State | undefined {\n    if (!isTagChar(code)) return nok(code);\n    if (isNonDigit(code)) hasNonDigit = true;\n    effects.consume(code);\n    return tagContent;\n  }\n\n  function end(code: Code): State | undefined {\n    if (!hasNonDigit) return nok(code);\n    effects.exit(\"tagContent\");\n    effects.exit(\"tag\");\n    return ok(code);\n  }\n}\n","import type {\n  Code,\n  Effects,\n  Extension,\n  State,\n  TokenizeContext,\n} from \"micromark-util-types\";\n\nconst DASH = 45;\nconst EQUALS = 61;\nconst LEFT_ANGLE = 60;\nconst RIGHT_ANGLE = 62;\n\nexport function arrowSyntax(): Extension {\n  return {\n    text: {\n      [DASH]: { name: \"arrow\", tokenize: tokenizeDash },\n      [EQUALS]: { name: \"arrow\", tokenize: tokenizeEquals },\n      [LEFT_ANGLE]: { name: \"arrow\", tokenize: tokenizeLeftAngle },\n    },\n  };\n}\n\nfunction tokenizeDash(\n  this: TokenizeContext,\n  effects: Effects,\n  ok: State,\n  nok: State,\n): State {\n  return start;\n\n  function start(code: Code): State | undefined {\n    if (code !== DASH) return nok(code);\n    effects.enter(\"arrow\");\n    effects.enter(\"arrowContent\");\n    effects.consume(code);\n    return afterFirst;\n  }\n\n  function afterFirst(code: Code): State | undefined {\n    if (code === RIGHT_ANGLE) {\n      effects.consume(code);\n      effects.exit(\"arrowContent\");\n      effects.exit(\"arrow\");\n      return ok;\n    }\n\n    if (code === DASH) {\n      effects.consume(code);\n      return afterSecond;\n    }\n\n    return nok(code);\n  }\n\n  function afterSecond(code: Code): State | undefined {\n    if (code !== RIGHT_ANGLE) return nok(code);\n    effects.consume(code);\n    effects.exit(\"arrowContent\");\n    effects.exit(\"arrow\");\n    return ok;\n  }\n}\n\nfunction tokenizeEquals(\n  this: TokenizeContext,\n  effects: Effects,\n  ok: State,\n  nok: State,\n): State {\n  return start;\n\n  function start(code: Code): State | undefined {\n    if (code !== EQUALS) return nok(code);\n    effects.enter(\"arrow\");\n    effects.enter(\"arrowContent\");\n    effects.consume(code);\n    return afterFirst;\n  }\n\n  function afterFirst(code: Code): State | undefined {\n    if (code === RIGHT_ANGLE) {\n      effects.consume(code);\n      effects.exit(\"arrowContent\");\n      effects.exit(\"arrow\");\n      return ok;\n    }\n\n    if (code === EQUALS) {\n      effects.consume(code);\n      return afterSecond;\n    }\n\n    return nok(code);\n  }\n\n  function afterSecond(code: Code): State | undefined {\n    if (code !== RIGHT_ANGLE) return nok(code);\n    effects.consume(code);\n    effects.exit(\"arrowContent\");\n    effects.exit(\"arrow\");\n    return ok;\n  }\n}\n\nfunction tokenizeLeftAngle(\n  this: TokenizeContext,\n  effects: Effects,\n  ok: State,\n  nok: State,\n): State {\n  return start;\n\n  function start(code: Code): State | undefined {\n    if (code !== LEFT_ANGLE) return nok(code);\n    effects.enter(\"arrow\");\n    effects.enter(\"arrowContent\");\n    effects.consume(code);\n    return afterLeft;\n  }\n\n  function afterLeft(code: Code): State | undefined {\n    if (code === DASH) {\n      effects.consume(code);\n      return leftDash;\n    }\n\n    if (code === EQUALS) {\n      effects.consume(code);\n      return leftEquals;\n    }\n\n    return nok(code);\n  }\n\n  function leftDash(code: Code): State | undefined {\n    if (code === DASH) {\n      effects.consume(code);\n      effects.exit(\"arrowContent\");\n      effects.exit(\"arrow\");\n      return ok;\n    }\n    effects.exit(\"arrowContent\");\n    effects.exit(\"arrow\");\n    return ok(code);\n  }\n\n  function leftEquals(code: Code): State | undefined {\n    if (code === EQUALS) {\n      effects.consume(code);\n      effects.exit(\"arrowContent\");\n      effects.exit(\"arrow\");\n      return ok;\n    }\n    effects.exit(\"arrowContent\");\n    effects.exit(\"arrow\");\n    return ok(code);\n  }\n}\n","import type { Extension } from \"mdast-util-from-markdown\";\n\nexport function wikilinkFromMarkdown(): Extension {\n  return {\n    enter: {\n      wikilink(token) {\n        this.enter(\n          {\n            type: \"wikilink\",\n            value: \"\",\n            embedded: false,\n            path: \"\",\n            heading: \"\",\n            alias: \"\",\n          },\n          token,\n        );\n      },\n      wikilinkEmbedMarker() {\n        const node = this.stack[this.stack.length - 1] as any;\n        node.embedded = true;\n      },\n      wikilinkPath(token) {\n        const node = this.stack[this.stack.length - 1] as any;\n        node.path = this.sliceSerialize(token);\n      },\n      wikilinkHeading(token) {\n        const node = this.stack[this.stack.length - 1] as any;\n        node.heading = this.sliceSerialize(token);\n      },\n      wikilinkAlias(token) {\n        const node = this.stack[this.stack.length - 1] as any;\n        node.alias = this.sliceSerialize(token);\n      },\n    },\n    exit: {\n      wikilink(token) {\n        this.exit(token);\n      },\n    },\n  };\n}\n","import type { Extension } from \"mdast-util-from-markdown\";\n\nexport function highlightFromMarkdown(): Extension {\n  return {\n    enter: {\n      highlight(token) {\n        this.enter({ type: \"highlight\", children: [] }, token);\n      },\n    },\n    exit: {\n      highlightContent(token) {\n        const node = this.stack[this.stack.length - 1] as any;\n        node.children = [{ type: \"text\", value: this.sliceSerialize(token) }];\n      },\n      highlight(token) {\n        this.exit(token);\n      },\n    },\n  };\n}\n","import type { Extension } from \"mdast-util-from-markdown\";\n\nexport function commentFromMarkdown(): Extension {\n  return {\n    enter: {\n      comment(token) {\n        this.enter({ type: \"comment\", value: \"\" }, token);\n      },\n    },\n    exit: {\n      commentContent(token) {\n        const node = this.stack[this.stack.length - 1] as any;\n        node.value = this.sliceSerialize(token);\n      },\n      comment(token) {\n        this.exit(token);\n      },\n    },\n  };\n}\n","import type { Extension } from \"mdast-util-from-markdown\";\n\nexport function tagFromMarkdown(): Extension {\n  return {\n    enter: {\n      tag(token) {\n        this.enter({ type: \"tag\", value: \"\" }, token);\n      },\n      tagContent(token) {\n        const node = this.stack[this.stack.length - 1] as any;\n        if (node.type === \"tag\") node.value = this.sliceSerialize(token);\n      },\n    },\n    exit: {\n      tag(token) {\n        this.exit(token);\n      },\n    },\n  };\n}\n","import type { Extension } from \"mdast-util-from-markdown\";\n\nconst arrowMap: Record<string, string> = {\n  \"->\": \"&rarr;\",\n  \"-->\": \"&rArr;\",\n  \"=>\": \"&rArr;\",\n  \"==>\": \"&rArr;\",\n  \"<-\": \"&larr;\",\n  \"<--\": \"&lArr;\",\n  \"<=\": \"&lArr;\",\n  \"<==\": \"&lArr;\",\n};\n\nexport function arrowFromMarkdown(): Extension {\n  return {\n    enter: {\n      arrow(token) {\n        this.enter({ type: \"arrow\", value: \"\" }, token);\n      },\n    },\n    exit: {\n      arrow(token) {\n        const node = this.stack[this.stack.length - 1] as any;\n        const raw = this.sliceSerialize(token);\n        node.value = arrowMap[raw] ?? raw;\n        this.exit(token);\n      },\n    },\n  };\n}\n"],"mappings":"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","names":["codes","isLineEnding","tokenize","tokenize","codes","HASH","tokenize","DASH","EQUALS"]}